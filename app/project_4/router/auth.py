from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field
from starlette import status
from typing import Annotated
from sqlalchemy.orm import Session
from database import SessionLocal
from models import Users
from passlib.context import CryptContext
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer

from datetime import timedelta, datetime, timezone    # used to set or create the expire time for the JWT token

from jose import jwt,JWTError    # to create the JWT

router = APIRouter(prefix="/auth", tags = ['Auth'])  
# prefix will mean that all the the endpoint that starts with "/auth" will be handled by this router function
# tags will provide the tag or a seperate section in the swagger api for better visualization 

# secret key can be anything that you wish like name or some bunch of characters and numbers
# but make sure the secret_key is extremely unique and impossible to bruteforce
SECRET_KEY ='8285af54f488857a158a3c01fb785a03'
ALGORITHM = 'HS256'



# creating the hashing funciton using the bcrypt as scheme, used to hash the password
bcrypt = CryptContext(schemes=['bcrypt'], deprecated='auto' )


# creating an dependencies that every api enpoint uses to decode the token 
# we need to decode the token often because that is the only way to verify the client

# the argument tokenUrl refers to endpoint where the token is generated by verifing the username and password
# so whatever function that uses this dependecy will run the "/auth/token" endpoint is the request doen't have token
# so from "/auth/token" endpoint the token is obtained
oauth2_bearer = OAuth2PasswordBearer(tokenUrl='auth/token')


# Creating pydantic model for user data request validation
class UserData(BaseModel):
    email: str
    username: str = Field(min_length=3)
    first_name: str = Field(min_length=1)
    last_name:str = Field(min_length=1)
    password:str = Field(min_length=8)
    role:str


class Token(BaseModel):
    access_token: str
    token_type: str

def getDB():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# creating the dependency for database
db_dependency = Annotated[Session, Depends(getDB)]




@router.post("/", status_code=status.HTTP_201_CREATED)
async def createUser(db: db_dependency, userdata : UserData):
    user = Users(
        email = userdata.email,
        username = userdata.username,
        first_name = userdata.first_name,
        last_name = userdata.last_name,
        hashed_password = bcrypt.hash(userdata.password),
        role = userdata.role,
        active = True
    )
    
    db.add(user)
    db.commit()



# creating the function to check the user is exist(authentication)
def authUser(db, username, password):
    user = db.query(Users).filter(Users.username == username).first()
    if not user:
        return False
    if bcrypt.verify(password, user.hashed_password):
        return user
    return False

# creatign the fucntion to create jwt token
def create_access_token(username: str, user_id: int, role: str, expires_delta: timedelta):

    encode = {"sub": username, "id": user_id, "role": role}
    expires = datetime.now(timezone.utc) + expires_delta

    encode.update({"exp": expires})
    return jwt.encode(encode, SECRET_KEY, algorithm= ALGORITHM)

# creating the python function that every endpoint funciton will use to check the token authenticity
# here token argument is a string object that depends on the oauth2passwordbearer function that has the token URL
async def get_current_user(token: Annotated[str, Depends(oauth2_bearer)]):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) # here algorithms argument can be str or [str] 
        username: str = payload.get('sub')
        user_id: int = payload.get("id")
        user_role: str = payload.get("role")
        if username is None or user_id is None:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Could not validate user")
        
        return {'username': username, "id": user_id, "role": user_role}
    
    except JWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Could not validate user")




@router.post("/token", response_model= Token ,status_code=status.HTTP_201_CREATED)
async def getToken(data : Annotated[OAuth2PasswordRequestForm, Depends()], db: db_dependency):
    user = authUser(db, data.username, data.password)

    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Could not validate user")

    token = create_access_token(user.username, user.id, user.role, timedelta(minutes=20))

    return {"access_token": token, "token_type":"bearer"}


class password_data(BaseModel):
    current_password: str
    new_password: str

# creating the request for changing the password
@router.put("/change_password", status_code=status.HTTP_204_NO_CONTENT)
async def changePassword(user: Annotated[dict, Depends(get_current_user)], passwords: password_data, db: db_dependency):
    if user is None:
        raise HTTPException(status_code=401, detail="Failed Authentication")
    
    user_data = db.query(Users).filter(user.get('username') == Users.username).first()

    if not bcrypt.verify(passwords.current_password, user_data.hashed_password):
        raise HTTPException(status_code=401, detail="Wrong password")
    
    user_data.hashed_password = bcrypt.hash(passwords.new_password)

    db.add(user_data)
    db.commit()


# creating the request to view the user details
@router.get("/user", status_code=status.HTTP_200_OK)
async def get_user_details(db: db_dependency, user: Annotated[dict, Depends(get_current_user)]):
    if user is None:
        raise HTTPException(status_code=401, detail="Authenticaiton Failed")
    
    user_data = db.query(Users).filter(Users.id == user.get("id")).first()


    return {
        "email": user_data.email,
        "user_name": user_data.username,
        "first_name": user_data.first_name,
        "last_name": user_data.last_name,
        "role": user_data.role,
        "user_id": user_data.id,
        "active": user_data.active
        }
